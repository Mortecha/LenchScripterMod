{
  "name": "Lench Scripter Mod",
  "tagline": "Besiege Python scripting mod",
  "body": "[![GitHub license](https://img.shields.io/github/license/lench4991/LenchScripterMod.svg?style=flat-square)](https://github.com/lench4991/LenchScripterMod/blob/master/LICENSE.md)\r\n[![GitHub release](https://img.shields.io/github/release/lench4991/LenchScripterMod.svg?style=flat-square)](https://github.com/lench4991/LenchScripterMod/releases)\r\n[![GitHub total downloads](https://img.shields.io/github/downloads/lench4991/LenchScripterMod/total.svg?style=flat-square)](https://github.com/lench4991/LenchScripterMod/releases)\r\n\r\nThis mod enables you to control your Besiege machine Python scripts.\r\nChanging sliders or toggles and triggering actions allows you to create controllers, stabilisators, autopilots or anything you can dream up to guide your machines.\r\n\r\nRequires [Spaar's Mod Loader](http://forum.spiderlinggames.co.uk/forum/main-forum/besiege-early-access/modding/8432-spaar-s-mod-loader-1-3-3-besiege-v0-27).\r\n\r\nIncludes an API for modders and enabling integration with other mods.\r\n\r\n**For documentation and everything else you want to know, see the [wiki page](https://github.com/lench4991/BesiegeScripterMod/wiki).**\r\n\r\n\r\n***\r\n\r\nWith this guide, I will try to show you how to get started using my scripting mod. I will start with very simple examples with thorough explanation and continue to more advanced machines with only conceptual remarks.\r\n\r\nExamples:  \r\n1. [Writing your first script](#1-writing-your-first-script)  \r\n2. [Something useful](#2-something-useful)  \r\n3. [Controlling anything](#3-controlling-anything)  \r\n4. [First flight](#4-first-flight)  \r\n\r\n### How it works\r\n\r\nThe mod looks for scripts in the `/Besiege_Data/Scripts/` folder. By default, it will look for a script with the same name as the machine, but you can change that by opening Script options window (Ctrl+U).\r\n\r\n![Finding the script file](http://i.imgur.com/YxUyb8g.jpg)\r\n\r\nIf you see the green checkmark near the script file input field, it means that the mod has found your script file and will run it when you start the simulation.\r\n\r\nThis is how the mod finds the right script to run. Save your machine, create a .py file with a matching name in Scripts folder and you're ready to go.\r\n\r\nAlternatively, you can embed the script inside the machine file for sharing on workshop.\r\n\r\n### 1. Writing your first script\r\n\r\nLet's make something simple. We want a vehicle that can run at different speeds. We will do this by changing it's wheel's speed sliders at a key press.\r\n\r\nIf you looked around in [Block handlers page](https://github.com/lench4991/LenchScripterMod/wiki/Block-handlers), you might have noticed the function called  \r\n `SetSliderValue(string sliderName, float value)`. This is what we will be calling.\r\n\r\n***\r\n\r\nFirst we need the block we want to manipulate. We get that by calling `Besiege.GetBlock(string blockId)` function with the block's ID. To get the blocks identifier, point at a block and press `LeftShift`. You will see the this.\r\n\r\n![Block identifiers](http://i.imgur.com/HjrLMaK.jpg)\r\n\r\nThese are actually two block identifiers for the same block. You can use either of those. The first one (name + number) is the sequential identifier. It's the most simple way to select your block, but you must be careful because it's number \r\nmight change if you place more wheels.\r\n\r\nThe second identifier is the block's GUID. This one will not change unless you delete the block. It can also be seen in the .bsg file. If you are modifying your machine a lot, you will probably want to use this one.\r\n\r\nLet's say we decide to use GUIDs. At the beginning of the script we can get the block references and save them in a variable to avoid typing them again.\r\n\r\n```python\r\nleft_wheel = Besiege.GetBlock(\"9d771b0d-d61c-4f35-a4bb-8f5f8daad308\")\r\nright_wheel = Besiege.GetBlock(\"7b700250-b1fd-4aae-834e-c1db9f8b5d8e\")\r\n```\r\n\r\n***\r\n\r\nThe first parameter to SetSliderValue function specifies the slider we want to change. Some blocks have multiple sliders, so this is necessary. To select a slider, just look at it's name in the block's mapper window:\r\n\r\n![Block mapper](http://i.imgur.com/tuxlKOV.jpg)\r\n\r\nNow we can set the wheels to super fast, even beyond what you're allowed to in-game.\r\n```python\r\nleft_wheel.SetSliderValue(\"SPEED\", 4)\r\nright_wheel.SetSliderValue(\"SPEED\", 4)\r\n```\r\n\r\n***\r\n\r\nTry running the script. It's not what we want yet. We want the speed to change at the press of a key.\r\n\r\nTo do this, we need to write a function:\r\n```python\r\ndef Update():\r\n    # handle key press\r\n```\r\n\r\nThis function will be called on every frame of the simulation. Inside, we can check for key presses and update our slider values.\r\n\r\nLet's create a variable called `v` for speed. Every time we press I, we will increase it, and every time we press K, we will decrease it. Then we update the slider value.\r\n\r\n```python\r\nv = 1\r\n\r\ndef Update():\r\n    if Input.GetKey(KeyCode.I):\r\n        v += 0.2\r\n    if Input.GetKey(KeyCode.K):\r\n        v -= 0.2\r\n    left_wheel.SetSliderValue(\"SPEED\", v)\r\n    right_wheel.SetSliderValue(\"SPEED\", v)\r\n```\r\n\r\nWe checked if key I or K are pressed by calling functions from UnityEngine.Input class. You can read more about how to use it [here](http://docs.unity3d.com/ScriptReference/Input.html).\r\n\r\nThere we go. We can now change the speed of the car while driving it!  \r\nWant to see how the speed changes? Press `Ctrl+I` to open the Watchlist, type `v` into the field and press add.\r\nYou can now see the variable value and even change it by clicking on it.\r\n\r\n### 2. Something useful\r\n\r\nYou know how nice it would be sometimes if steering hinges reset their angle when you stopped pressing the key? We can make that!\r\n\r\nLet's upgrade our code from the last example. We will need block handlers for the steering hinges.\r\n\r\n```python\r\nleft_hinge = Besiege.GetBlock(\"STEERING HINGE 1\")\r\nright_hinge = Besiege.GetBlock(\"STEERING HINGE 2\")\r\n```\r\n\r\nThe `GetBlock()` function finds the block by it's identifier and returns the block handler object. Variables `left_hinge` and `right_hinge` now contain objects representing our left and right steering hinges. This way, we can use [features only steering blocks have](https://github.com/lench4991/LenchScripterMod/wiki/Block-handlers#steering), like the `left_hinge.SetAngle(angle)`.\r\n\r\n***\r\n\r\nJust like the last time, we will check for key presses inside Update() function body, then set the angle of the hinges. Let's check for LeftArrow and RightArrow key presses.\r\n\r\n```python\r\nv = 1\r\n\r\ndef Update():\r\n    if Input.GetKey(KeyCode.I):\r\n        v += 0.2\r\n    if Input.GetKey(KeyCode.K):\r\n        v -= 0.2\r\n\r\n    if Input.GetKey(KeyCode.LeftArrow):\r\n        # steer left\r\n    if Input.GetKey(KeyCode.RightArrow):\r\n        # steer right\r\n\r\n    left_wheel.SetSliderValue(\"SPEED\", v)\r\n    right_wheel.SetSliderValue(\"SPEED\", v)\r\n```\r\n\r\nWe now have the if sentences that will run when the arrow keys are pressed. Now we just need to create a variable that will hold our angle.\r\n\r\nA really elegant way to do this is initializing it at the start of the Update function, then increase it or decrease it in the if sentence blocks.\r\n\r\n```python\r\nangle = 0\r\nif Input.GetKey(KeyCode.LeftArrow):\r\n    angle += 40\r\nif Input.GetKey(KeyCode.RightArrow):\r\n    angle -= 40\r\n```\r\n\r\nThis way if no key is pressed, the angle will remain zero. If both keys are pressed simultaneously, the angle will be `0 + 40 - 40 = 0`.\r\n\r\nNow we just call the SetAngle functions and we're done.\r\n\r\n```python\r\nleft_wheel.SetAngle(angle)\r\nright_wheel.SetSliderValue(angle)\r\n```\r\n\r\n***\r\n\r\n### 3. Controlling anything\r\n\r\nNow let's try do the same thing, but with a spinning block. This way we'll show how to control your machine indirectly. This approach can be used to control almost anything.\r\n\r\nHere's our machine:  \r\n![Steering machine](http://i.imgur.com/VtIdw0Q.jpg)\r\n\r\n***\r\n\r\nTo control the steering angle through a spinning block, we need to set just the right speed for the spinning block to turn to the desired angle.\r\n\r\nBut to know what speed to apply to the block, we need to know where we are steering first in order to adjust. Our steering angle is the difference between where the car is pointing and where the wheels are pointing.\r\n\r\nWe need car heading and steering block heading angles. Good way to get them is by using EulerAngles block property.\r\nThis property will return a vector of three angles, one for each axis (x, y, z) in range from 0 to 360.\r\n\r\n```python\r\nstarting_block = Besiege.GetBlock(\"STARTING BLOCK 1\")\r\nspinning_block = Besiege.GetBlock(\"SPINNING 1\")\r\n\r\ndef Update():\r\n    car_angles = starting_block.EulerAngles\r\n    spinning_angles = spinning_block.EulerAngles\r\n```\r\n\r\n![Euler angles](http://i.imgur.com/trOQO9y.png)\r\n\r\nBy toying around with the car a bit, we can see that the values we want are in the vector's `y` component. Now we need to calculate the angle between them. This is tricky, because we need to get the shortest angle and we can't just substract the smaller from the bigger one. For example, the shortest angle between 330째 and 30째 is 60째 and not 300째.\r\n\r\nGood thing is we can access methods from UnityEngine Mathf module. Function Mathf.DeltaAngle will get us what we want.\r\n```python\r\ncar_heading = starting_block.EulerAngles.y\r\nspinning_heading = spinning_block.EulerAngles.y\r\nsteering_angle = Mathf.DeltaAngle(car_heading, spinning_heading)\r\n```\r\n\r\n![Negative angle](http://i.imgur.com/KnS0YmA.png)\r\n\r\nMathf.DeltaAngle calculates the shortest angle from `car_heading` to `spinning_heading`. That's why if car_heading is bigger, we get negative value, which means **negative steering angle is left and positive is right**, as you can see on the picture.\r\n\r\n\r\n***\r\n\r\nWe have our steering angle. Now we need to know how we want to steer. We will create a variable called `target_angle`.\r\nTarget angle will be 30 degrees to the left (-30) if we're holding down left arrow and 30 degrees to the right (+30) when we're holding down right arrow. If we let go of the keys, the `target_angle` will return back to 0.\r\n\r\nWe will do this the same way as we set the angle in the last example.\r\n\r\n```python\r\nstarting_block = Besiege.GetBlock(\"STARTING BLOCK 1\")\r\nspinning_block = Besiege.GetBlock(\"SPINNING 1\")\r\n\r\ndef Update():\r\n    car_heading = starting_block.EulerAngles.y\r\n    spinning_heading = spinning_block.EulerAngles.y\r\n    steering_angle = Mathf.DeltaAngle(car_heading, spinning_heading)\r\n\r\n    target_angle = 0\r\n    if Input.GetKey(KeyCode.LeftArrow):\r\n        target_angle += 30\r\n    if Input.GetKey(KeyCode.RightArrow):\r\n        target_angle -= 30\r\n\r\n```\r\n\r\n***\r\n\r\nNow we need to use the information about our car to calculate which way and how fast to spin our spinning block to make it point in direction of target_angle. To keep it simple for now, let's just try substracting target angle from the current angle. The maximum difference between the angles is 60, so if we divide it by 120, we will get maximum 0.5 speed slider value, keeping the steering smooth.\r\n\r\n```python\r\nspeed = (steering_angle - target_angle)/120\r\n```\r\n\r\nThis way we convert the steering error into spinning block speed. If the angles match, the speed will be zero, meaning the spinning block will hold the angle. If the angles are off, the speed will be right to correct the angle.\r\n\r\nNow we only need to set the slider value:\r\n\r\n```python\r\nspinning_block.SetSliderValue(\"SPEED\", speed)\r\n```\r\n\r\n**[The result is satisfying.](https://gfycat.com/SneakyBrownGnat)**\r\n\r\n### 4. First flight\r\n\r\nYou should be able to do some real scripting by now. And that's what we're going to do.\r\n\r\nHere's our next objective:  \r\n![Drone](http://i.imgur.com/Ay6wrin.jpg)\r\n\r\nCreate a drone with four spinning blocks for propellers. Invert two of those to balance it. We will be writing an autopilot stabilisation script for the drone. It's quite stable on it's own, so it won't be that hard to tune it, but it will teach you the concepts behind it. We will also include a reactionary wheel in the center to turn the drone left and right.\r\n\r\nFirst, find out at what speed of the spinning blocks the drone hovers at the same altitude. With my drone, that speed was 0.9. Save it to a global variable `HOVER_SPEED`. The speeds we will be applying to the spinning blocks will all be deviations of this value.\r\n\r\n***\r\n\r\nSimilarly to the previous example, we will be matching drones parameters to our target parameters and then adjusting the input with a bit more complex controllers. Let's start by defining target variables and handling input for pitch, roll and altitude.\r\n\r\n```python\r\ntarget_altitude = 0\r\n\r\ndef Update():\r\n    \"\"\"\r\n    Functions in Python have their own local scope.\r\n    To make sure we are changing global variables instead of creating\r\n    new local variables with the same name,\r\n    we use the global keyword.\r\n    \"\"\"\r\n    global target_altitude\r\n    \r\n    target_pitch = 0\r\n    if Input.GetKey(KeyCode.UpArrow):\r\n        target_pitch = 10\r\n    if Input.GetKey(KeyCode.DownArrow):\r\n        target_pitch = -10\r\n\r\n    target_roll = 0\r\n    if Input.GetKey(KeyCode.LeftArrow):\r\n        target_roll = 10\r\n    if Input.GetKey(KeyCode.RightArrow):\r\n        target_roll = -10\r\n\r\n    if Input.GetKey(KeyCode.I):\r\n        target_altitude = target_altitude + 5 * Time.deltaTime\r\n    if Input.GetKey(KeyCode.K):\r\n        target_altitude = target_altitude - 5 * Time.deltaTime\r\n```\r\n\r\nAs you see, we will be using `I` and `K` to move the target altitude. When the key is held, we will be moving it by 5 units per second. We do this by multiplying 5 with [Time.deltaTime](http://docs.unity3d.com/ScriptReference/Time-deltaTime.html).\r\n\r\nArrow keys will be controlling pitch and roll. Each will bank the drone for 10 degrees in it's direction.\r\n\r\n![Drone angles](http://i.imgur.com/29vbr7H.png)\r\n\r\n***\r\n\r\nSame as before, the first step is getting machine's parameters: angles and altitude. We need to convert them so they match our target values. Because we will be using more advanced control loop feedback mechanisms (controllers) than last time, we will also need the rate of change (speed) of the machine's parameters.\r\n\r\n```python\r\nposition = starting_block.Position\r\nrotation = starting_block.EulerAngles\r\n    \r\nmachine_altitude = position.y\r\nvertical_velocity = (machine_altitude - last_altitude) / Time.deltaTime\r\n    \r\nmachine_pitch = rotation.x\r\npitch_velocity = Mathf.DeltaAngle(machine_pitch, last_pitch) / Time.deltaTime\r\n    \r\nmachine_roll = rotation.z\r\nroll_velocity = Mathf.DeltaAngle(machine_roll, last_roll) / Time.deltaTime\r\n    \r\nlast_altitude = machine_altitude\r\nlast_pitch = machine_pitch\r\nlast_roll = machine_roll\r\n```\r\n\r\nDon't forget to initialize last_* variables at the start of the script.\r\n\r\nWith our machine and target parameters ready, it's time to program our controllers. Real drones do this by implementing [PID (proportional-integral-derivative) controller](https://en.wikipedia.org/wiki/PID_controller) and so do we.\r\n\r\n***\r\n\r\nThe PID controller accounts for present values, past values and possible future values. It determines the output based on three components:\r\n* proportional error - distance to the target value\r\n* integral error - proportional error accumulated over time\r\n* derivative error - error based on the rate of change (speed)\r\n\r\nThe proportional error is basically what we used in the previous example - we subtracted the values. For altitude controller, this would be:\r\n```python\r\naltitude_p_error = target_altitude - machine_altitude\r\n```\r\n\r\nThe integral error is accumulated proportional error. A good example of why we need this is if we're lifting heavy loads with the drone. When lifting, greater rotor speeds are required to keep the altitude. The controller would accumulate the error and learn to apply more power to all rotors.\r\n```python\r\naltitude_i_error = altitude_i_error + altitude_p_error * Time.deltaTime\r\n```\r\n\r\nFinally the derivative component which is simply the speed or rate of change. Accounting for this will greatly help us fix on the target, especially when the controlled value carries momentum, in this case our drone falling or rising rapidly.\r\n```python\r\naltitude_d_error = - vertical_velocity\r\n```\r\n\r\nThe output value will be normalized sum of these components, multiplied by their gain coefficients:\r\n```python\r\naltitude_p_gain = 1\r\naltitude_i_gain = 1\r\naltitude_d_gain = 1\r\n```\r\n\r\nFor now, we can set them to 1. Later, when tuning the controllers, we will change these values to manipulate how the controllers react to change.\r\n\r\nThe output value for the altitude controller is now:\r\n```python\r\n    altitude_adjustment = ( altitude_p_error * altitude_p_gain +\r\n                            altitude_i_error * altitude_i_gain +\r\n                            altitude_d_error * altitude_d_gain) / 20\r\n```\r\n\r\nThe controller returns zero when the machine is on target. By dividing the output value by 20, it's proportional component will now return 1 when 20 units below target or -1 when 20 units above target. With this, we try to normalize the output between -1 (rotors standing still) and +1 (rotors at double hover speed).\r\n\r\nWe implement similar controllers also for pitch and roll.\r\n\r\n***\r\n\r\nNow it's time to apply new values.\r\n\r\nAltitude adjustment applies to all rotors equally. Positive pitch adjustment means the pitch angle is too big so the drone needs to be tilted forward. When doing that, the rear rotor speeds will be increased and the front decreased. That is why we put negative sign infront of pitch adjustment for front rotors. We do similarly for roll adjustment.\r\n \r\n```python\r\nfront_left_speed = HOVER_SPEED + HOVER_SPEED * (altitude_adjustment - pitch_adjustment - roll_adjustment)\r\nfront_right_speed = HOVER_SPEED + HOVER_SPEED * (altitude_adjustment - pitch_adjustment + roll_adjustment)\r\nrear_left_speed = HOVER_SPEED + HOVER_SPEED * (altitude_adjustment + pitch_adjustment - roll_adjustment)\r\nrear_right_speed = HOVER_SPEED + HOVER_SPEED * (altitude_adjustment + pitch_adjustment + roll_adjustment)\r\n```\r\n\r\n***\r\n\r\nWith all controllers in place, it is time to tune them.\r\n\r\n![PID tuning](https://upload.wikimedia.org/wikipedia/commons/c/c0/Change_with_Ki.png)\r\n\r\nWe watch how far the drone overshoots the target. We want the drone to reach the target as fast as possible, but minimise the overshoot and the wobble that comes after it. Overshooting with altitude could prove extremely problematic, especially when trying to land the drone, as it could slam it into the ground. Overshooting with pitch or roll is more acceptable as we want to keep good responsiveness of the controls.\r\n\r\nWhen tuning the pitch and roll controllers, we notice that it the drone sometimes starts shaking violently. It seems that the drone carries too much rotational inertia, so it just swings over the target value and then comes back with the same speed. To fix it, we will lower the `d_gain` parameter.\r\n\r\nIf you tuned your controllers right, the drone should be easy and responsive to fly.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}